this["web-track-browser"] = (function () {
  'use strict';

  function defineGlobalValue(global, name, api) {
    Object.defineProperty(global, name, {
      writable: true,
      enumerable: true,
      configurable: true,
      value: api
    });
  }
  function defineGlobal(global, name, api, hook) {
    if (hook) {
      hook(() => {
        defineGlobalValue(global, name, api);
      });
    } else {
      defineGlobalValue(global, name, api);
    }
  }

  Array(32);

  class WebTracker {
    constructor(opt) {
      this.timer = null;
      this.time = 10;
      this.count = 10;
      this.arr = [];
      var _a, _b;
      this.time = (_a = opt.time) != null ? _a : 10;
      this.count = (_b = opt.count) != null ? _b : 10;
      if (opt.host.startsWith("http://") || opt.host.startsWith("https://")) {
        this.url = opt.host + "/logstores/" + opt.logstore + "/track";
      } else {
        this.url = "https://" + opt.project + "." + opt.host + "/logstores/" + opt.logstore + "/track";
      }
      this.opt = opt;
      if (opt.installUnloadHook && typeof opt.installUnloadHook === "function") {
        opt.installUnloadHook(() => {
          this.sendImmediateInner();
        });
      }
    }
    assemblePayload(arr) {
      const payload = {
        __logs__: arr
      };
      if (this.opt.tags) {
        payload.__tags__ = this.opt.tags;
      }
      if (this.opt.topic) {
        payload.__topic__ = this.opt.topic;
      }
      if (this.opt.source) {
        payload.__source__ = this.opt.source;
      }
      return JSON.stringify(payload);
    }
    platformSend() {
      if (this.opt.sendPayload && typeof this.opt.sendPayload === "function") {
        const payloadStr = this.assemblePayload(this.arr);
        this.opt.sendPayload(this.url, payloadStr);
      }
    }
    transString(obj) {
      let newObj = {};
      for (let i in obj) {
        if (typeof obj[i] == "object") {
          newObj[i] = JSON.stringify(obj[i]);
        } else {
          newObj[i] = String(obj[i]);
        }
      }
      return newObj;
    }
    sendImmediateInner() {
      if (this.arr && this.arr.length > 0) {
        this.platformSend();
        if (this.timer != null) {
          clearTimeout(this.timer);
          this.timer = null;
        }
        this.arr = [];
      }
    }
    sendInner() {
      if (this.timer) {
        if (this.arr.length >= this.count) {
          clearTimeout(this.timer);
          this.timer = null;
          this.sendImmediateInner();
        }
      } else {
        const that = this;
        if (this.arr.length >= this.count || this.time <= 0) {
          this.sendImmediateInner();
        } else {
          this.timer = setTimeout(function() {
            that.sendImmediateInner();
          }, this.time * 1e3);
        }
      }
    }
    send(originLog) {
      const obj = this.transString(originLog);
      this.arr.push(obj);
      this.sendInner();
    }
    sendImmediate(originLog) {
      const obj = this.transString(originLog);
      this.arr.push(obj);
      this.sendImmediateInner();
    }
    sendBatchLogs(originLogs) {
      const logs = originLogs.map((originLog) => this.transString(originLog));
      this.arr.push(...logs);
      this.sendInner();
    }
    sendBatchLogsImmediate(originLogs) {
      const logs = originLogs.map((originLog) => this.transString(originLog));
      this.arr.push(...logs);
      this.sendImmediateInner();
    }
    overwriteTransString(stsPlugin) {
      this.transString = stsPlugin.transString;
    }
    getOpt() {
      return this.opt;
    }
  }

  var __async = (__this, __arguments, generator) => {
    return new Promise((resolve, reject) => {
      var fulfilled = (value) => {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      };
      var rejected = (value) => {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      };
      var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
      step((generator = generator.apply(__this, __arguments)).next());
    });
  };
  function sendBeacon(url, payload) {
    if (navigator && navigator.sendBeacon) {
      return navigator.sendBeacon(`${url}?APIVersion=0.6.0`, payload);
    }
    return false;
  }
  function sendUseXhr(url, reqPayload) {
    const httpRequest_ = new window.XMLHttpRequest();
    httpRequest_.open("POST", `${url}?APIVersion=0.6.0`, true);
    httpRequest_.send(reqPayload);
  }
  function send(url, payload) {
    try {
      if (payload.length >= 32768) {
        sendUseXhr(url, payload);
        return;
      }
      if (!sendBeacon(url, payload)) {
        sendUseXhr(url, payload);
      }
    } catch (ex) {
      if (window && window.console && typeof window.console.error === "function") {
        console.error("Failed to log to ali log service because of this exception:\n" + ex);
        console.error("Failed log data:", url);
      }
    }
  }
  function sendPutlog(url, payLoad, stsPlugin) {
    return __async(this, null, function* () {
      try {
        url = url.slice(0, -6);
        const { data, header } = yield stsPlugin.process(url, payLoad);
        const httpRequest_ = new window.XMLHttpRequest();
        httpRequest_.open("POST", url, true);
        for (let k in header) {
          httpRequest_.setRequestHeader(k, header[k]);
        }
        httpRequest_.send(data);
      } catch (error) {
        if (window && window.console && typeof window.console.error === "function") {
          console.error("Failed to log to ali log service because of this exception:\n" + error);
          console.error("Failed log data:", url);
        }
      }
    });
  }
  class WebTrackerBrowser extends WebTracker {
    constructor(opt) {
      const superOpt = Object.assign({}, opt, {
        installUnloadHook: (hook) => {
          window.addEventListener("beforeunload", () => {
            hook();
          });
        },
        sendPayload: (url, payload) => {
          send(url, payload);
        }
      });
      super(superOpt);
    }
    useStsPlugin(stsPlugin) {
      this.getOpt().sendPayload = (url, payload) => {
        sendPutlog(url, payload, stsPlugin);
      };
      this.overwriteTransString(stsPlugin);
    }
  }

  defineGlobal(window, "SLS_Tracker", WebTrackerBrowser);

  return WebTrackerBrowser;

})();
//# sourceMappingURL=web-track-browser.global.js.map
